// /src/sim800.rs
use embassy_time::{Duration, with_timeout, Timer};
use heapless::String;
use defmt::{info, error, warn};

use crate::constants::*;
use crate::custom_strings::{extract_between_delimiters, extract_after_delimiter, separate_chars_by_commas};
use crate::hardware::{Uart2Rx, Uart2Tx, Sim800Control};
use crate::phone_book::PhoneBook;
use embassy_sync::blocking_mutex::raw::CriticalSectionRawMutex;
use embassy_sync::channel::{Sender, Receiver};

// Types for communication
#[derive(Clone, defmt::Format, PartialEq)]
pub enum Command {
    Init,
    SendMessage {
        phone_number: String<MAX_PHONE_LENGTH>,
        message: String<SIM800_LINE_BUFFER_SIZE>,
    },
    SendAlarmSms {
        message: String<SIM800_LINE_BUFFER_SIZE>,
    },
    CallWithDtmf {
        phone_number: String<MAX_PHONE_LENGTH>,
        dtmf: String<DTMF_PACKET_LENGTH>,
    },
    CallAlarmWithDtmf {
        dtmf: String<DTMF_PACKET_LENGTH>,
    },
    HandleIncomingCall {
        phone_number: String<MAX_PHONE_LENGTH>,
    },
    UpdateTime,
}

// Events generated by SIM800 (URCs)
#[derive(Clone, defmt::Format)]
pub enum SimEvent {
    SmsReceived {
        number: String<MAX_PHONE_LENGTH>,
        message: String<SIM800_LINE_BUFFER_SIZE>,
    },
    CallReceived {
        number: String<MAX_PHONE_LENGTH>,
    },
    DtmfReceived(char),
    CallEnded,
    // Added CallExecuted variant to report status of outgoing alarm calls
    CallExecuted(bool),
}

pub struct Sim800Driver {
    tx: Uart2Tx,
    rx: Uart2Rx,
    control: Sim800Control,
    phone_book: PhoneBook,
    // Buffer for reading lines
    line_buf: [u8; 128],
    // Deduplication state
    last_alarm_dtmf: String<DTMF_PACKET_LENGTH>,
    last_alarm_time: u64,
}

impl Sim800Driver {
    pub fn new(tx: Uart2Tx, rx: Uart2Rx, control: Sim800Control) -> Self {
        Self {
            tx,
            rx,
            control,
            phone_book: PhoneBook::new(),
            line_buf: [0u8; 128],
            last_alarm_dtmf: String::new(),
            last_alarm_time: 0,
        }
    }

    async fn read_line(&mut self) -> Result<&str, ()> {
        let mut pos = 0;
        loop {
            let mut buf = [0u8; 1];
            match self.rx.read(&mut buf).await {
                Ok(_) => {
                    let b = buf[0];
                    if b == b'\n' {
                        if pos > 0 && self.line_buf[pos-1] == b'\r' {
                             pos -= 1;
                        }
                        if let Ok(s) = core::str::from_utf8(&self.line_buf[..pos]) {
                            return Ok(s);
                        } else {
                            return Err(());
                        }
                    } else if b != b'\r' {
                        if pos < self.line_buf.len() {
                            self.line_buf[pos] = b;
                            pos += 1;
                        }
                    }
                }
                Err(_) => return Err(()),
            }
        }
    }
    
    async fn send_str(&mut self, s: &str) {
        if s.is_empty() { return; }
        let _ = self.tx.write(s.as_bytes()).await;
    }

    async fn send_cmd_wait_ok(&mut self, cmd: &str, timeout_ms: u64) -> Result<(), ()> {
        self.send_str(cmd).await;
        self.send_str("\r\n").await;
        
        with_timeout(Duration::from_millis(timeout_ms), async {
            loop {
                let mut cpbr_data: Option<String<MAX_PHONE_LENGTH>> = None;
                
                {
                    let line = self.read_line().await?;
                    if line.trim() == "OK" { return Ok(()); }
                    if line.trim() == "ERROR" { return Err(()); }
                    
                    if line.contains("+CPBR:") {
                        if let Some(num) = extract_between_delimiters(line, ",\"", "\",") {
                            let mut s = String::<MAX_PHONE_LENGTH>::new();
                            if s.push_str(num).is_ok() {
                                cpbr_data = Some(s);
                            }
                        }
                    }
                }

                if let Some(num) = cpbr_data {
                    let _ = self.phone_book.add_number(&num);
                }
            }
        }).await.map_err(|_| ())?
    }
    
    // -----------------------------------------------------------------------
    // High Level Operations
    // -----------------------------------------------------------------------

    pub async fn power_on(&mut self) {
        self.control.sim800_enable.set_high();
        info!("Powering on SIM800...");
        Timer::after(Duration::from_secs(INIT_SIM800_DELAY_SECONDS as u64)).await;
        
        let cmds = [
            "AT", "ATE0", "AT+CMEE=1", "AT+CLIP=1", "AT+CMGF=1",
            "AT+CSCS=\"GSM\"", "AT+CNMI=1,2,0,1,0", "AT+CSMP=49,167,0,0",
            "AT+CREG=1", "AT+DDET=1",
        ];

        for cmd in cmds {
            let mut attempts = 0;
            loop {
                if self.send_cmd_wait_ok(cmd, 1000).await.is_ok() {
                    break;
                }
                attempts += 1;
                if attempts > 3 {
                    error!("CMD failed: {}", cmd);
                    break;
                }
                Timer::after(Duration::from_millis(500)).await;
            }
        }

        for i in 1..=8 {
            let mut buf = String::<16>::new();
            use core::fmt::Write;
            let _ = write!(buf, "AT+CPBR={}", i);
            let _ = self.send_cmd_wait_ok(&buf, 2000).await;
        }
        
        info!("SIM800 Initialized");
    }

    pub async fn send_sms(&mut self, number: &str, message: &str) -> Result<(), ()> {
        self.send_str("AT+CMGS=\"").await;
        self.send_str(number).await;
        self.send_str("\"\r\n").await;

        let res = with_timeout(Duration::from_secs(5), async {
            loop {
                 let mut b = [0u8; 1];
                 if self.rx.read(&mut b).await.is_ok() {
                     if b[0] == b'>' { return Ok::<(), ()>(()); }
                 }
            }
        }).await;

        if res.is_err() { return Err(()); }

        self.send_str(message).await;
        let ctrl_z = [0x1Au8];
        let _ = self.tx.write(&ctrl_z).await;

        self.send_cmd_wait_ok("", 10000).await
    }

    pub async fn make_call_dtmf(&mut self, number: &str, dtmf: &str) -> Result<(), ()> {
        self.send_str("ATD").await;
        self.send_str(number).await;
        self.send_str(";\r\n").await;

        if self.send_cmd_wait_ok("", 5000).await.is_err() {
            // "OK" usually comes after ATD
        }

        let result = with_timeout(Duration::from_secs(20), async {
             loop {
                let line = self.read_line().await?;
                if line.contains(ONLINE_SIGNAL) { return Ok(true); } 
                if line.contains("NO CARRIER") || line.contains("BUSY") { return Err(()); }
                if line.contains("+DTMF: *") { return Ok(true); }
             }
        }).await;

        if result.is_err() {
            self.send_cmd_wait_ok("AT+CHUP", 1000).await.ok();
            return Err(());
        }

        let mut out_buf = [0u8; 64];
        if let Some(csv) = separate_chars_by_commas(dtmf, &mut out_buf) {
             let mut cmd = String::<64>::new();
             use core::fmt::Write;
             let _ = write!(cmd, "AT+VTS=\"{}\"", csv);
             self.send_cmd_wait_ok(&cmd, 5000).await?;
        }

        let confirm_res = with_timeout(Duration::from_secs(5), async {
             loop {
                let line = self.read_line().await?;
                if line.contains("+DTMF: #") { return Ok::<(), ()>(()); }
             }
        }).await;

        self.send_cmd_wait_ok("AT+CHUP", 1000).await.ok();
        
        match confirm_res {
            Ok(_) => Ok(()),
            Err(_) => Err(()),
        }
    }

    pub async fn handle_incoming_call_flow(&mut self, event_channel: &Sender<'static, CriticalSectionRawMutex, SimEvent, 4>) {
        self.send_cmd_wait_ok("ATA", 2000).await.ok();
        Timer::after(Duration::from_secs(1)).await;
        
        let mut cmd = String::<32>::new();
        use core::fmt::Write;
        let _ = write!(cmd, "AT+VTS=\"{}\"", ONLINE_SIGNAL);
        self.send_cmd_wait_ok(&cmd, 2000).await.ok();

        let mut dtmf_buf = String::<DTMF_PACKET_LENGTH>::new();
        
        let _ = with_timeout(Duration::from_secs(10), async {
            loop {
                let line = self.read_line().await?;
                if let Some(val) = extract_after_delimiter(line, "+DTMF: ") {
                     let c = val.trim().chars().next().unwrap_or('\0');
                     if c != '\0' {
                         dtmf_buf.push(c).ok();
                         event_channel.send(SimEvent::DtmfReceived(c)).await;
                     }
                }
                if dtmf_buf.len() >= DTMF_PACKET_LENGTH { return Ok::<(), ()>(()); }
                if line.contains("NO CARRIER") { return Err(()); }
            }
        }).await;

        let _ = write!(cmd, "AT+VTS=\"{}\"", CONFIRMATION_SIGNAL);
        self.send_cmd_wait_ok(&cmd, 2000).await.ok();
        
        Timer::after(Duration::from_secs(1)).await;
        self.send_cmd_wait_ok("AT+CHUP", 1000).await.ok();
        
        event_channel.send(SimEvent::CallEnded).await;
    }

    pub async fn run(&mut self, 
        cmd_channel: Receiver<'static, CriticalSectionRawMutex, Command, 4>,
        event_channel: Sender<'static, CriticalSectionRawMutex, SimEvent, 4>
    ) {
        self.power_on().await;
        
        let mut uptime_sec: u64 = 0;
        
        loop {
            use embassy_futures::select::{select, Either};
            
            let selection = select(self.read_line(), cmd_channel.receive()).await;
            uptime_sec += 1; 

            match selection {
                Either::First(line_res) => {
                    let mut sms_sender: Option<String<MAX_PHONE_LENGTH>> = None;
                    
                    if let Ok(line) = line_res {
                        if !line.trim().is_empty() {
                            info!("RX: {}", line);
                            
                            if line.contains("+CMT:") {
                                if let Some(num) = extract_between_delimiters(line, "\"", "\"") {
                                    let mut s = String::new();
                                    if s.push_str(num).is_ok() {
                                        sms_sender = Some(s);
                                    }
                                }
                            } else if line.contains("+CLIP:") {
                                if let Some(num) = extract_between_delimiters(line, "\"", "\"") {
                                    let mut s_num = String::new(); s_num.push_str(num).ok();
                                    event_channel.send(SimEvent::CallReceived { number: s_num }).await;
                                }
                            } else if line.contains("+DTMF:") {
                                if let Some(val) = extract_after_delimiter(line, "+DTMF: ") {
                                    let c = val.trim().chars().next().unwrap_or(' ');
                                    event_channel.send(SimEvent::DtmfReceived(c)).await;
                                }
                            }
                        }
                    }

                    if let Some(sender) = sms_sender {
                        if let Ok(msg) = self.read_line().await {
                             let mut s_msg = String::new();
                             s_msg.push_str(msg).ok();
                             event_channel.send(SimEvent::SmsReceived { number: sender, message: s_msg }).await;
                        }
                    }
                },
                Either::Second(cmd) => {
                    info!("Processing command: {:?}", cmd);
                    match cmd {
                        Command::Init => self.power_on().await,
                        Command::SendMessage { phone_number, message } => {
                            let _ = self.send_sms(&phone_number, &message).await;
                        },
                        Command::SendAlarmSms { message } => {
                             let mut target_num = String::<MAX_PHONE_LENGTH>::new();
                             let mut found = false;
                             if let Some(num) = self.phone_book.get_first() {
                                 target_num.push_str(num).ok();
                                 found = true;
                             }
                             if found {
                                 let _ = self.send_sms(&target_num, &message).await;
                             }
                        },
                        Command::CallAlarmWithDtmf { dtmf } => {
                             let mut target_num = String::<MAX_PHONE_LENGTH>::new();
                             let mut found = false;
                             if let Some(num) = self.phone_book.get_first() {
                                 target_num.push_str(num).ok();
                                 found = true;
                             }
                             
                             if found {
                                 // Check duplicate
                                 let is_duplicate = (dtmf == self.last_alarm_dtmf) && 
                                                    (uptime_sec.saturating_sub(self.last_alarm_time) < 120); 
                                 
                                 if is_duplicate {
                                     warn!("Skipping duplicate alarm call for DTMF {} (Last: {}s ago)", dtmf, uptime_sec - self.last_alarm_time);
                                     // Inform logic task that we treated this as "done"
                                     event_channel.send(SimEvent::CallExecuted(true)).await;
                                 } else {
                                     info!("Calling Alarm: {} with DTMF: {}", target_num, dtmf);
                                     match self.make_call_dtmf(&target_num, &dtmf).await {
                                         Ok(_) => {
                                             info!("Alarm confirmed (#).");
                                             self.last_alarm_dtmf = dtmf.clone();
                                             self.last_alarm_time = uptime_sec;
                                             // Notify success
                                             event_channel.send(SimEvent::CallExecuted(true)).await;
                                         },
                                         Err(_) => {
                                             warn!("Alarm call failed/unconfirmed.");
                                             // Notify failure
                                             event_channel.send(SimEvent::CallExecuted(false)).await;
                                         }
                                     }
                                 }
                             } else {
                                 warn!("No phone number for alarm call!");
                                 event_channel.send(SimEvent::CallExecuted(false)).await;
                             }
                        },
                        Command::CallWithDtmf { phone_number, dtmf } => {
                            let _ = self.make_call_dtmf(&phone_number, &dtmf).await;
                        },
                        Command::HandleIncomingCall { .. } => {
                            self.handle_incoming_call_flow(&event_channel).await;
                        },
                        Command::UpdateTime => {
                            self.send_cmd_wait_ok("AT+CCLK?", 1000).await.ok();
                        },
                    }
                }
            }
        }
    }
}